\documentclass{article}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsthm}

\newcommand{\Z}{\mathbb{Z}}
\newcommand*{\divmod}[2]{\mathbf{divmod}\left( #1, #2 \right)}
\newcommand{\nmid}{\hspace{-4pt}\not|\hspace{2pt}}

\newtheorem{theorem}{Theorem}

\begin{document}
\title{Application of Discrete Models}
\author{Adam Zlehovszky}
\maketitle

\section{Representation of Integers}

\subsection{Euclidean division}
If $a,b \in \Z$ with $b \ne 0$ then $\exists ! q,r \in \Z$ such that $a=qb+r$ where $0 \le r < |b|$.
This is the \emph{Euclidean division} or \emph{long division} of the \emph{dividend} $a$ with the \emph{divisor} $b$.
The results of the division are the \emph{quotient} $q$ and the \emph{remainder} $r$.
The standard notation for the remainder is $a \bmod b$. In algorithmic setting we use $q, r \gets \divmod{a}{b}$.

\subsection{Number systems}

Let $1 < b \in \Z$ be the \emph{base} of the \emph{number system}.
For each $0 \le n \in \Z$ there exists a unique $1 \le d \in \Z$ and a unique set of \emph{digits} $0 \le n_1, n_2, \ldots, n_{d-1} < b$ all integers, such that
\[
    n = \sum_{k=0}^{d-1}n_k b^{k}.
\]
If $n = 0$, then $d=1$ and $n_0 = 0$. Otherwise $d = \left \lfloor \log_{b} n \right \rfloor + 1$ and we can extract the digits of $n$ with long division, since
\begin{align*}
    n & = n_{d-1}b^{d-1} + \cdots + n_2 b^2 + n_1 b + n_0 \\
      & = \left( n_{d-1}b^{d-2} + \cdots + n_2 b + n_1 \right)b + n_0 
\end{align*}
where the quotient $n_{d-1}b^{d-2} + \cdots + n_2 b + n_1$ is a $d-1$ digit number and $n_0$ is the extracted digit.

We call $n_0$ the \emph{least significant digit} and $n_{d-1}$ the \emph{most significant digit}.
The storage order of digits is called \emph{little endian} if we start at the least significant digits and move towards the most significant one. Otherwise it is called \emph{big endian}.

\subsection{Operations on Integers}

\subsubsection{Addition}

Let us assume that we have two unsigned integers stored as digits in a number system with base $b$:
\[
    n^{(i)} = \sum_{k=0}^{d^{(i)}-1} n_k^{(i)} b^k,
\]
for $i=1,2$.
The following algorithm computes the digits of the sum $s = n^{(1)} + n^{(2)} = \sum_{k=0}^{d^{(s)}-1} s_k b^k$:
\begin{algorithm}
    \caption{Standard addition}
    \label{alg:standard-add}
    \begin{algorithmic}[1]
        \Procedure{StandardAddition}{$n^{(1)}$, $n^{(2)}$}
            \State $d^{(s)} \gets \max\left( d^{(1)}, d^{(2)} \right)$
            \State $c \gets 0$
            \For{$k=0,\ldots,d^{(s)}-1$}
                \State $c,\ s_k \gets \divmod{n_k^{(1)} + n_k^{(2)} + c}{b}$
            \EndFor
            \State \textbf{return} $s$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

In Algorithm \ref{alg:standard-add} we assume that $n^{(i)}_k = 0$ if $k \ge d^{(i)}$ for $i=1,2$.
The time complexity of the standard addition is $O\left(d^{(s)}\right)$.

\subsubsection{Multiplication}

Let $n^{(i)}$'s defined same as above for $i=1,2$.
We will compute the digits of the product $p=n^{(1)} \cdot n^{(2)} = \sum_{k=0}^{d^{(p)}-1} p_k b^k$ with the naive multiplication method:
\begin{algorithm}
    \caption{Naive multiplication}
    \label{alg:naive-mul}
    \begin{algorithmic}[1]
        \Procedure{NaiveMultiplication}{$n^{(1)}$, $n^{(2)}$}
            \State $d^{(p)} \gets d^{(1)} + d^{(2)}$
            \For{$k=0,\ldots,d^{(p)}-1$}
                \State $p_k \gets 0$
            \EndFor
            \For{$j=0,\ldots,d^{(2)}-1$}
                \State $c \gets 0$
                \For{$i=0,\dots,d^{(1)}-1$}
                    \State $c,\ p_{i+j} \gets \divmod{p_{i+j} + n^{(1)}_i n^{(2)}_j + c}{b}$
                \EndFor
            \State $p_{d^{(1)}+j} \gets c$
            \EndFor
            \State \textbf{return} $p$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

The time-complexity of Algorithm \ref{alg:naive-mul} is $O(d^{(1)} \cdot d^{(2)})=O(d^2)$, where $d=\max\left( d^{(1)}, d^{(2)}\right)$.

Karatsuba's idea for faster multiplication can be demonstrated on two-digit numbers. Let
\[
    x = x_1 b + x_0,\ \textrm{and}\ y = y_1 b + y_0
\]
with $0 \le x_i, y_i < b$ integers.
Naive multiplication of $x$ and $y$ is
\begin{align*}
    z = xy &= \left(x_1 b + x_0 \right)\left(y_1 b + y_0 \right) \\
           &= x_1 y_1 b^2 + \left(x_1 y_0 + x_0 y_1\right)b + x_0 y_0 \\
           &= z_1 b^2 + z_1 b + z_0.
\end{align*}
This is 4 multiplication and 1 addition.

Now we can express
\begin{align*}
    z_1 &= x_1 y_0 + x_0 y_1 \\
        &= x_1 y_0 + x_0 y_1 - x_1 y_1 + x_1 y_1 - x_0 y_0 + x_0 y_0 \\
        &= \left(x_1 + x_0\right)y_1 + \left(x_1 + x_0\right)y_0 - x_1 y_1 - x_0 y_0 \\
        &= \left(x_1 + x_0\right)\left(y_1 + y_0\right) - x_1 y_1 - x_0 y_0 \\
        &= \left(x_1 + x_0\right)\left(y_1 + y_0\right) - z_2 - z_0.
\end{align*}
This is 3 multiplication and 3 additions.
By extending this idea to more than two digits recursively, the multiplication algorithm performs $O(d^{\log_2 3}) \approx O(d^{1.58})$ single-digit multiplication.

Fast Fourier Transform based algorithms can achieve $O(d \log d)$ complexity.

\subsection{Exponentiation}

We want to compute $x^n$ for some $1 \le n \in \Z$ and $x$ that has multiplication as an operation.

\paragraph{Naive exponentiation}
By repeated multiplication, we can compute
\[
    x^n = \underbrace{x \cdot x \cdots x}_\textrm{$n$ times}.
\]
This method requires $n-1$ multiplications.

\paragraph{Repeated squaring}
If $n=2^s$ for $0 < s \in \Z$, then
\[
    x^{\left(2^s\right)} = \left(x^2\right)^{\left(2^{s-1}\right)}.
\]
This way we can compute $x^n$ with $\log_2 n = s$ multiplications with the algorithm below:
\begin{algorithm}
    \caption{Repeated squaring}
    \label{alg:repeated-squaring}
    \begin{algorithmic}[1]
        \Procedure{RepeatedSquaring}{$x$, $s$}
            \State $y \gets x$
            \For{$k=0,\ldots,s-1$}
                \State $y \gets y^2$
            \EndFor
            \State \textbf{return} y
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\paragraph{Fast exponentiation}

If we write $n = \sum_{k=0}^{d-1}n_k 2^k$ in binary, then
\begin{align*}
    x^n & = x^{\left( \sum_{k=0}^{d-1}n_k 2^k \right)} \\
        & = \prod_{k=0}^{d-1} x^{\left( n_k 2^k \right)} \\
        & = \prod_{k=0}^{d-1} x^{\left( 2^k \right)^{n_k}}.
\end{align*}

Since $y^{n_k} = y$ if $n_k=1$ and $y=1$ otherwise, we arrive at the following algorithm:
\begin{algorithm}
    \caption{Fast exponentiation}
    \label{alg:fast-exp}
    \begin{algorithmic}[1]
        \Procedure{FastExp}{$x$, $n$}
            \State $y \gets 1$
            \While{$n > 0$}
                \State $n, r \gets \divmod{n}{2}$
                \If{$r=1$}
                    \State $y \gets y \cdot x$
                \EndIf
                \State $x \gets x^2$
            \EndWhile
            \State \textbf{return} y
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

This algorithm requires $O(\log_2 n)$ multiplication.

\section{Number Theory and its Applications}

\subsection{Divisibility}

If $aq=b$, then we say that $a$ is a \emph{divisor} of $b$, or $b$ is a \emph{multiple} of $a$.
The notation is $a \mid b$. Otherwise $a \nmid b$.
If $a \mid b$, then long division has remainder of $0$ and in case of integers $\frac{b}{a}$ is an integer as well.

The following properties are natural consequences of the definition.
\begin{enumerate}
    \item For every $a$, we have that $a \mid a$.
    \item $a \mid 0$, for every $a$.
    \item If $0 \mid a$, then $a=0$.
    \item If $a \mid b$ and $b \mid c$, then $a \mid c$.
    \item If $a \mid b$ and $c \mid d$, then $ab \mid cd$.
    \item If $a \mid b$, then $ac \mid bc$ for every $c$.
    \item If $ac \mid bc$ and $c \neq 0$, then $a \mid b$.
    \item If $a \mid b_i$ for some finite indices $i$, then $a \mid \sum_i c_i b_i$ for every $c_i$.
\end{enumerate}

If $\varepsilon \mid a$ for every $a$, then we call $\varepsilon$ a \emph{unit element}.
The unit elements of $\Z$ are $\pm 1$.

If $a \mid b$ and $b \mid a$ and $a \neq b$, then we call $a$ and $b$ \emph{associated elements}.
Two elements $a$ and $b$ are associated if and only if $a=\varepsilon b$ for some unit element $\varepsilon$.
Consequently, $a$ and $b$ are associated integers if and only if $|a| = |b|$.

Let $p \neq 0$ be a non-unit element.
We say that $p$ is an \emph{irreducible element} if $p=ab$ implies that $a$ or $b$ is an associated element of $p$ (and the other is a unit).
If an element is not irreducible, then it is \emph{composite}.
We call $p$ a \emph{prime element} if $p \mid ab$ implies that $p \mid a$ or $p \mid b$.
If $p$ is an irreducible element, then it is also a prime element.
In case of integers, the reverse is also true, i.e.\ every prime element is irreducible.

\begin{theorem}[The Fundamental Theorem of Arithmetic]
    \label{th:fta}
    If $a \neq 0$ is not a unit element, then it is a product of irreducible elements.
    The product is unique (up to ordering and up to multiplication with unit elements).
\end{theorem}

If $1 < n \in \Z$, then the \emph{canonical form} of
\[
    n = p_1^{\alpha_1} \cdots \ p_r^{\alpha_r}
\]
where $p_i$'s are different prime numbers (positive prime elements of $\Z$) and $\alpha_i > 0$ for all $i=1,\ldots,r$.

\begin{theorem}[Euclid]
    There are infinitely many prime numbers.
\end{theorem}
\begin{proof}
    Let us assume that there are only finite many primes $p_1,\ldots,p_n$.
    In this case the long division of $n = p_1 \cdots p_n + 1$ with $p_i$ yields a remainder of $1$ for every prime.
    This means that $n$ does not have canonical form, which contradicts Theorem \ref{th:fta}.
\end{proof}

\begin{theorem}[Distribution of prime numbers]
    The following statements illustrate some properties of the distribution of prime numbers:

    \begin{enumerate}
        \item If $N > 1$, then $\exists a > 2$ such that $a + 1, a + 2, \ldots, a+N$ are all composite numbers.
        \item For every $M > 2$, there is a prime number between $M$ and $2M$.
    \end{enumerate}
\end{theorem}

Let $\pi(x)$ denote the number of positive prime numbers below $x$.
\begin{theorem}[Prime Number Theorem]
    An approximation of $\pi(x)$ is $\frac{x}{\ln x}$. In other words
    \[
        \lim_{x \to +\infty} \frac{\pi(x)}{x/\ln x} = 1.
    \]
\end{theorem}

\subsection{Greatest common divisor}

The \emph{greatest common divisor} of $a_1,\ldots,a_n$ elements is $d$, if
\begin{itemize}
    \item $d \mid a_i$ for all $i$, i.e.\ $d$ is a common divisor of the elements and
    \item if $d' \mid a_i$ for all $i$, then $d' \mid d$ that is $d$ is maximal with respect to divisibility.
\end{itemize}
From the definition, it is clear that if $d$ is a greatest common divisor and $\varepsilon$ is a unit element, then $\varepsilon d$ is also a greatest common divisor.
We usually fix a greatest common divisor for integers by nominating the positive one.
We will use the notation $\gcd \left(a_1,\ldots,a_n \right)$.

From the definition we can see that
\begin{enumerate}
    \item $\gcd(a,0)=a$,
    \item $\gcd(0,0)=0$,
    \item $\gcd(a,b)=\gcd(b,a)$,
    \item $\gcd(a, b) = \gcd(a - b, b)$ or in general $\gcd(a-qb, b) = \gcd(a,b)$ for any $q$. Specifically $\gcd(a \bmod b, b) = \gcd(a, b)$.
\end{enumerate}

From the last property we have that
\begin{align*}
    \gcd(a, b) &= \gcd(a \bmod b, b) \\
               &= \gcd\left(a \bmod b, b \bmod \left(a \bmod b\right)\right) \\
               &= \gcd\left(\left(a \bmod b\right) \bmod b \bmod \left(a \bmod b\right), b \bmod \left(a \bmod b\right)\right).
\end{align*}
Let us define the recurrence relation $r_0 = a$, $r_1 = b$ and $r_{n+2} = r_{n} \bmod r_{n+1}$.
In this case the equations above become
\begin{align*}
    \gcd(r_0, r_1) &= \gcd(r_2, r_1) \\
                   &= \gcd\left(r_2, r_3\right) \\
                   &= \gcd\left(r_4, r_3\right).
\end{align*}
We can swap the arguments of $\gcd$, so
\begin{align*}
    \gcd(r_0, r_1) &= \gcd(r_1, r_2) \\
                   &= \gcd\left(r_2, r_3\right) \\
                   &= \gcd\left(r_3, r_4\right)
\end{align*}
The sequence in strictly decreasing, that is $r_n > r_{n+1}$ and $r_{n} \ge 0$ from $n=2$.
This means that there is an index $N$ such that $r_N = 0$, but $r_{N-1} > 0$.
From the properties and definition of recurrence relation it is clear, that
\[
    \gcd(a, b) = \gcd(r_{N-1}, 0) = r_{N-1}.
\]

The argument above gives the \emph{Euclidean algorithm} in recursive form:
\begin{algorithm}
    \caption{Recursive Euclidean algorithm}
    \label{alg:recursive-gcd}
    \begin{algorithmic}[1]
        \Procedure{GCD}{$a$, $b$}
            \If{$b = 0$}
                \State \textbf{return} a
            \EndIf
            \State \textbf{return} \Call{GCD}{$b$, $a \bmod b$}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

We can transform the recursion into a loop.
At any given step, we only need $r_{n}$ and $r_{n+1}$ to produce $r_{n+2}$.
\begin{algorithm}
    \caption{Iterative Euclidean algorithm}
    \label{alg:iterative-gcd}
    \begin{algorithmic}[1]
        \Procedure{GCD}{$a$, $b$}
            \State $r_{\mathrm{old}},\ r_{\mathrm{new}} \gets a,\ b$
            \While{$r_{\mathrm{new}} \neq 0$}
                \State $r_{\mathrm{old}},\ r_{\mathrm{new}} \gets r_{\mathrm{new}},\ r_{\mathrm{old}} \bmod r_{\mathrm{new}}$
            \EndWhile
            \State \textbf{return} $r_{\mathrm{old}}$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

For later applications we not only need the $\gcd(a, b) = d$ but two additional elements $x$ and $y$, such that
\[
    d = ax + by.
\]
We can extend Euclidean algorithm to calculate $x$ and $y$.
For this, we are going to ensure that during the algorithm we are updating producing $x_n$ and $y_n$ for each $r_n$, such that
\[
    r_n = ax_n + by_n.
\]
This will be our loop invariant property, i.e.\ this property will be true for $n$ and $n+1$ whenever we enter the body of the loop and we will make sure that it is true for $n+2$ after the last statement of the body.
Before the first execution of the loop body, the values $x_0 = 1$, $y_0 = 0$, $x_1 = 0$ and $y_0 = 1$ will suffice.
Let $q = \left\lfloor r_n / r_{n+1} \right\rfloor$. During the body of the loop we have that
\begin{align*}
    r_{n+2} &= r_n \bmod r_{n+1} \\
            &= r_n -  q r_{n+1} \\
            &= \left(a x_n + b y_n\right) -q\left(a x_{n+1} + b y_{n+1}\right) \\
            &= a\left(x_n - q x_{n+1}\right) + b\left(y_n - q y_{n+1}\right),
\end{align*}
so $x_{n+2} = x_n - q x_{n+1}$ and $y_{n+2} = y_n - q y_{n+1}$ will work.
Again, we only need tha last two value of $x$ and $y$ during the calculations.
We call the procedure \emph{Extended Euclidean algorithm}:
\begin{algorithm}
    \caption{Extended Euclidean algorithm}
    \label{alg:extended-gcd}
    \begin{algorithmic}[1]
        \Procedure{GCD}{$a$, $b$}
            \State $r_{\mathrm{old}},\ x_{\mathrm{old}},\ y_{\mathrm{old}} \gets a,\ 1,\ 0$
            \State $r_{\mathrm{new}},\ x_{\mathrm{new}},\ y_{\mathrm{new}} \gets b,\ 0,\ 1$
            \While{$r_{\mathrm{new}} \neq 0$}
                \State $r_{\mathrm{old}},\ q,\ r_{\mathrm{new}} \gets r_{\mathrm{new}},\ \divmod{r_{\mathrm{old}}}{r_{\mathrm{new}}}$
                \State $x_{\mathrm{old}},\ x_{\mathrm{new}} \gets x_{\mathrm{new}},\ x_{\mathrm{old}} - q x_{\mathrm{new}}$
                \State $y_{\mathrm{old}},\ y_{\mathrm{new}} \gets y_{\mathrm{new}},\ y_{\mathrm{old}} - q y_{\mathrm{new}}$
            \EndWhile
            \State \textbf{return} $r_{\mathrm{old}},\ x_{\mathrm{old}},\ y_{\mathrm{old}}$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\end{document}